---
title: 实时环境光渲染
date: 2025-03-02 15:31:33
categories:
  - 图形学
  - games202
tags:
    - 环境光照渲染
---

<div align='center' ><font size=7>Shading from Enviroment Lighting</font></div>


### 理论基础
由此可以得到渲染方程：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302153649374.png)
可以通过蒙塔卡罗积分的方式求解，但是速度很慢。每一个shaderPoint都需要求解。只要用到sampling 一般不会用于实时渲染领域。
其实，根据渲染方程，我们发现以下特点：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302154102506.png)

第一种BRDF，积分域很小
第二种BRDF，积分内的函数很smooth。

着满足了PCSS中提到的不等式。
![](https://gitee.com/nhkao/pic-go/raw/master/20250301195129872.png)
因此我们可以把积分内的函数提取出来。得到下面约等式：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302154455654.png)
矩阵框内的部分，回忆PCF求解软阴影的部分，其实可以等价的理解为：**对Li的一部分区域采样，求均值=>模糊操作**，而这部分工作是可以在渲染之前完成的！可以联想mipmap的使用。
但是我们求解均值的意义是什么呢？
![](https://gitee.com/nhkao/pic-go/raw/master/20250302155158220.png)
左侧的图是我们求解渲染方程时的传统思路。要真正精准计算radiance，需要根据brdf随机采样。这其实就等同于在反射方向上采样filtered过的区域！
这就完成了积分左侧的部分。
对于右侧部分，根据微表面BRDF，我们做了一些大胆的假设，最终可以将一张多维的表打成两张二维表。
![](https://gitee.com/nhkao/pic-go/raw/master/20250302160945157.png)
这中拆分方式的方法名叫split sum.

### PRT
使用SH基函数，解决任意BRDF，包含shadow的情况！
![](https://gitee.com/nhkao/pic-go/raw/master/20250302163120851.png)
根据渲染方程，我们假设场景中只有光照在变，其他都不变。我们就把积分内拆解成了lighting和light transport。
对于前者，我们可以表示成：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302163334413.png)
对于后者，如果场景是不变的，我们也可以认为他是可以用球面函数。下面具体展开讨论：
#### Diffuse Case
![](https://gitee.com/nhkao/pic-go/raw/master/20250302163954401.png)
BRDF为常数，可以直接拿到外面去。交换积分与求和顺序，这时，积分内的部分本质上就是求light transport在基函数上的投影。因此，最后我们将公式转换为简单的点乘！
代价就是：场景不能动，光源可以随时切换。（不过 这可以根据SH的性质快速求解）
针对光源旋转问题，SH有个重要性质：
**旋转光源=>旋转基函数=>旋转后的基函数都可以被同阶的原始基函数线性表示！**

#### glossy Case
![](https://gitee.com/nhkao/pic-go/raw/master/20250302165740377.png)
会稍微复杂一些（其实就是Diffuse的基础上再做一次投影，得到一个关于观察方向o的light transport矩阵）。此外，由于glossy的比较高频，对于SH的阶次也应该选择更高的频率，因为卷积操作会过滤掉两者中的高频部分。

### 代码部分 
本次作业是关于diffuse的PRT计算，主要可以分为两个部分
1. 预计算部分。主要计算的是环境光照在球谐函数下的投影值。包含了Lightning部分和light Transport部分
2. 将前面预计算的部分在shader中点乘，得到shaderPoint的radiance。
   
#### 计算环境光Lighting球谐投影
[球谐函数内容介绍](https://zhuanlan.zhihu.com/p/351289217)
[球谐函数前n阶表](https://zh.wikipedia.org/wiki/%E7%90%83%E8%B0%90%E5%87%BD%E6%95%B0)
计算系数是，我们使用投影操作，也即将环境光投影到球谐函数上，就可以计算得到相应阶次下的系数。使用的公式如下：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302202617370.png)
在实际计算中，我们会将积分转为为求和，如下：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302202713831.png)

接下来直接看代码部分：
```c++
//辅助函数
    float CalcPreArea(const float &x, const float &y)
    {
        return std::atan2(x * y, std::sqrt(x * x + y * y + 1.0));
    }

    float CalcArea(const float &u_, const float &v_, const int &width,
                   const int &height)
    {
        // transform from [0..res - 1] to [- (1 - 1 / res) .. (1 - 1 / res)]
        // ( 0.5 is for texel center addressing)
        float u = (2.0 * (u_ + 0.5) / width) - 1.0;
        float v = (2.0 * (v_ + 0.5) / height) - 1.0;

        // shift from a demi texel, mean 1.0 / size  with u and v in [-1..1]
        float invResolutionW = 1.0 / width;
        float invResolutionH = 1.0 / height;

        // u and v are the -1..1 texture coordinate on the current face.
        // get projected area for this texel
        float x0 = u - invResolutionW;
        float y0 = v - invResolutionH;
        float x1 = u + invResolutionW;
        float y1 = v + invResolutionH;
        float angle = CalcPreArea(x0, y0) - CalcPreArea(x0, y1) -
                      CalcPreArea(x1, y0) + CalcPreArea(x1, y1);

        return angle;
    }

    const Eigen::Vector3f cubemapFaceDirections[6][3] = {
        {{0, 0, 1}, {0, -1, 0}, {-1, 0, 0}},  // negx
        {{0, 0, 1}, {0, -1, 0}, {1, 0, 0}},   // posx
        {{1, 0, 0}, {0, 0, -1}, {0, -1, 0}},  // negy
        {{1, 0, 0}, {0, 0, 1}, {0, 1, 0}},    // posy
        {{-1, 0, 0}, {0, -1, 0}, {0, 0, -1}}, // negz
        {{1, 0, 0}, {0, -1, 0}, {0, 0, 1}},   // posz
    };
```

```c++
//主函数
template <size_t SHOrder>
    std::vector<Eigen::Array3f> PrecomputeCubemapSH(const std::vector<std::unique_ptr<float[]>> &images,
                                                    const int &width, const int &height,
                                                    const int &channel)
    {
        std::vector<Eigen::Vector3f> cubemapDirs;
        cubemapDirs.reserve(6 * width * height);
        for (int i = 0; i < 6; i++)
        {
            Eigen::Vector3f faceDirX = cubemapFaceDirections[i][0];
            Eigen::Vector3f faceDirY = cubemapFaceDirections[i][1];
            Eigen::Vector3f faceDirZ = cubemapFaceDirections[i][2];
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    float u = 2 * ((x + 0.5) / width) - 1;
                    float v = 2 * ((y + 0.5) / height) - 1;
                    Eigen::Vector3f dir = (faceDirX * u + faceDirY * v + faceDirZ).normalized();
                    cubemapDirs.push_back(dir);
                }
            }
        }
        constexpr int SHNum = (SHOrder + 1) * (SHOrder + 1);
        std::vector<Eigen::Array3f> SHCoeffiecents(SHNum);
        for (int i = 0; i < SHNum; i++)
            SHCoeffiecents[i] = Eigen::Array3f(0);
        float sumWeight = 0;
        for (int i = 0; i < 6; i++)
        {
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    // TODO: here you need to compute light sh of each face of cubemap of each pixel
                    // TODO: 此处你需要计算每个像素下cubemap某个面的球谐系数
                    Eigen::Vector3f dir = cubemapDirs[i * width * height + y * width + x];
                    Eigen::Vector3d dirD = { dir.x(),dir.y(),dir.z() };
                    int index = (y * width + x) * channel;
                    Eigen::Array3f Le(images[i][index + 0], images[i][index + 1],
                                      images[i][index + 2]);

                    /*float u = 2 * ((x + 0.5) / width) - 1;
                    float v = 2 * ((y + 0.5) / height) - 1;*/
                    float area = CalcArea(x, y, width, height);
                    sumWeight += area;
                    for (int l = 0; l <= SHOrder; l++) 
                    {
                        for (int m = -l; m <= l; m++) 
                        {
                           float shVal = sh::EvalSH(l, m, dirD.normalized());
                           SHCoeffiecents[sh::GetIndex(l, m)] += Le * shVal * area;
                        }
                    }
                }
            }
        }
        return SHCoeffiecents;
    }
```
``PrecomputeCubemapSH``函数的入参是天空盒的六个面对应的图片以及相应的长宽，通道数信息。
``cubemapFaceDirections``函数是得到指定面对应的包围盒所在的朝向，这样，就实现了对于每个面上的每个像素，得到了唯一的光线方向。
``CalcArea``则是计算单一像素在球谐函数上对应的面积值
``sh::EvalSH``函数则是计算l阶，m次，dir方向下的球谐函数投影值，通过相应的权重计算(Le，area)得到该方向在该阶次下的球谐函数投影值。
通过对六个面的整体计算，我们就可以得到天空盒上每个像素对于球心的中心方向，得到环境光Lighting的投影值！

#### light Transport部分
对于unshadow部分
对于diffuse的BRDF，我们变换成下面等式：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302205115173.png)
这里，我们以mesh的顶点为起点，随机向其正半球面打出光线进行采样，加权平均后就可以得到light Transport值

对于shadow的部分，同样可以得到如下公式：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302205416144.png)
与unshadow不同的是，在光线采样时，如果求交到了别的三角形面片，则我们认为该点是在阴影中的。

```C++
virtual void preprocess(const Scene *scene) override
    {

        //...准备数据，得到images
        //计算得到环境光系数envCoeffs
        auto envCoeffs = ProjEnv::PrecomputeCubemapSH<SHOrder>(images, width, height, channel);
        //...
        m_TransportSHCoeffs.resize(SHCoeffLength, mesh->getVertexCount());
        fout << mesh->getVertexCount() << std::endl;
        for (int i = 0; i < mesh->getVertexCount(); i++)
        {
            const Point3f &v = mesh->getVertexPositions().col(i);
            const Normal3f &n = mesh->getVertexNormals().col(i);
            auto shFunc = [&](double phi, double theta) -> double {
                Eigen::Array3d d = sh::ToVector(phi, theta);
                const auto wi = Vector3f(d.x(), d.y(), d.z());
                double H = n.dot(wi);
                if (m_Type == Type::Unshadowed)
                {
                    // TODO: 此处你需要计算给定方向下的unshadowed传输项球谐函数值
                    return H > 0 ? H : 0;
                }
                else
                {
                    
                    // TODO: 此处你需要计算给定方向下的shadowed传输项球谐函数值
                    if (H > 0 && !scene->rayIntersect(Ray3f(v, wi)))
                    {
                        return H;
                    }
                    else
                    {
                        return 0;
                    }
                    return 0.0;
                }
            };
            auto shCoeff = sh::ProjectFunction(SHOrder, shFunc, m_SampleCount);
            for (int j = 0; j < shCoeff->size(); j++)
            {
                m_TransportSHCoeffs.col(i).coeffRef(j) = (*shCoeff)[j] / M_PI;
            }
        }

        // DO FOR Type::Interreflection
    }
```

对于diffuse Inter-reflection(bonus)，有如下等式：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302205742982.png)
也就是说，我们不光要得到前面计算得到的Lds部分，而且还要考虑到间接光线(不是环境光线直接照射到的)多次弹射到三角形上的情况。

```c++
    auto shRecurse(const Scene* scene, int order, const Point3f& v,
        const Normal3f& n)-> std::unique_ptr<std::vector<double>>
    {
        auto P_RR = []()->double
            {
                std::random_device rd;
                std::mt19937 gen(rd());
                std::uniform_real_distribution<> rng(0.0, 1.0);

                double q = rng(gen);
                double p = rng(gen);
                if (p > q)
                {
                    return p;
                }
                return 0;
            };
       
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_real_distribution<> rng(0.0, 1.0);

        std::unique_ptr<std::vector<double>> coeffs(new std::vector<double>());
        coeffs->assign(sh::GetCoefficientCount(order), 0.0);

        double alpha = rng(gen);
        double beta =  rng(gen);

        double pRR = P_RR();
        if (pRR ==0 || pRR <0.5)
        {
            return coeffs;
        }

        double phi = 2.0 * M_PI * beta;
        double theta = acos(2.0 * alpha - 1.0);
        Eigen::Array3d d = sh::ToVector(phi, theta);
        const auto wi = Vector3f(d.x(), d.y(), d.z());

        float projVal = std::max(n.dot(wi), 0.f);
        if (projVal <= 0)
        {
            return coeffs;
        }

        Intersection its;
        if (!scene->rayIntersect(Ray3f(v, wi), its))
            return coeffs;


        for (int p = 0; p < m_Bounce; ++p)
        {
            for (int i = 0; i < 3; ++i)
            {
                int index = static_cast<int>(its.tri_index[i]);
                const Point3f vRC = its.mesh->getVertexPositions().col(index);
                const Normal3f nRC = its.mesh->getVertexNormals().col(index);
                auto coeffRC = shRecurse(scene, order, vRC, nRC);

                for (int j = 0; j < SHCoeffLength; ++j)
                {                                    
                    (*coeffRC)[j] += m_TransportSHCoeffs.col(index).coeffRef(j) / pRR;

                    //(*coeffs)[j] += std::max(n.dot(wi), 0.f) * its.bary[i] * m_TransportSHCoeffs.col(index).coeffRef(j) / SampleSum;
                    (*coeffs)[j] += projVal * its.bary[i] * (*coeffRC)[j] / m_Bounce;
                }
            }
        }          
        return coeffs;
    }

    // DO FOR Type::Interreflection
    if (/*false && */m_Type == Type::Interreflection)
        {
            // TODO: leave for bonus
            Eigen::MatrixXf mTBonus(SHCoeffLength, mesh->getVertexCount());
            for (int i = 0; i < mesh->getVertexCount(); i++)
            {
                const Point3f& v = mesh->getVertexPositions().col(i);
                const Normal3f& n = mesh->getVertexNormals().col(i);

                std::unique_ptr<std::vector<double>> shCoeff(new std::vector<double>());
                shCoeff->assign(sh::GetCoefficientCount(SHOrder), 0.0);
                float spp = 64.;
                for (float i = 0; i < spp; ++i)
                {
                    auto coeff = shRecurse(scene, SHOrder, v, n);
                    for (int j = 0; j < shCoeff->size(); j++)
                    {
                        (*shCoeff)[j] += (*coeff)[j] / spp;
                    }
                }

                for (int j = 0; j < shCoeff->size(); j++)
                {
                
                    m_TransportSHCoeffs.col(i).coeffRef(j) += (*shCoeff)[j];
                }
            }
        }
```
这里主要考虑的是``shRecurse``函数，他类似与path Tracing，递归求解间接光线的Light Transport.

至此，我们实现了对于diffuse的BRDF求解预计算部分的全部工作。接下来，我们需要看到在js中是如何使用预计算结果的。

### 渲染预计算结果

首先，我们通过读取文件的方式计算得到预计算的结果，并将其放入两个全部变量precomputeL，precomputeLT.分别对应的是lighting和light Transport部分。
对于前者，他是一个固定值，因此，我们把它设为顶点属性值
```GLSL
attribute mat3 aPrecomputeLT;
```
对于后者，他与顶点相关，因此，我们设置一个uniform变量，其值与顶点一一对应。
```js
class PRTMaterial extends Material {

    constructor(color, specular, light, translate, scale,precomputeT, vertexShader, fragmentShader) {
        super({
            'uPrecomputeT':{ type: 'vec3fv', value: precomputeT },
        },
             ['aPrecomputeLT'], 
             vertexShader, fragmentShader, null);
    }
}
```

在shader中，代码如下：
```GLSL
attribute vec3 aVertexPosition;
attribute vec3 aNormalPosition;
attribute vec2 aTextureCoord;
attribute mat3 aPrecomputeLT;

uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec3 uPrecomputeT[9];

varying highp vec3 vColor;

void main(void) {

for(int i=0;i<3;++i)
{
    for(int j=0;j<3;++j)
    {
        vColor +=uPrecomputeT[3*i+j]*aPrecomputeLT[i][j];
    }
}
  //vColor=uPrecomputeT[1];

  gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix *
                vec4(aVertexPosition, 1.0);
}
```
我们将lighting 与 light Transport点乘，就可以得到最后shader的值了。这里``uPrecomputeT[9]``是一个9个长度的三维向量，这是因为我们一直使用的是三阶次的SH，每个向量代表一个颜色值。

此外，计算得到的效果可能会有偏差，这是由于显示器Gama校验的问题，这一块也需要注意下。
最终效果图如下：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302211857539.png)

### 环境光旋转
球谐函数具有这样的性质：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302212040228.png)
因此，我们推到出如下的公式：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302212145454.png)
其中，P(Ni)是指某个向量在球谐函数上的投影
因此，对于这部分的变换我们就可以理解为：
先计算2*l+1个任意方向的向量：N(-L)···N(L)在球谐函数上的投影，P(-L)···P(L),然后根据旋转矩阵，计算得到前面那些向量旋转后的向量值：R\*N(-L)···R\*N(L),于是，我们就计算得到了系数变换矩阵M。

整体的代码框架如下：
```JS
function getRotationPrecomputeL(precompute_L, rotationMatrix) {

	let rotationMatrix_inverse = mat4.create()
	mat4.invert(rotationMatrix_inverse, rotationMatrix);
	let r = mat4Matrix2mathMatrix(rotationMatrix_inverse);

    //计算第一阶次的变换矩阵3X3
	let LL3x3 = computeSquareMatrix_3by3(r);
    //计算第二阶次的变换矩阵5X5
	let LL5x5 = computeSquareMatrix_5by5(r);

	let result = [];
	for (let i = 0; i < 9; i++) {
		result[i] = [];
	}
	for (let i = 0; i < 3; i++) {
		let L_SH_R_3 = math.multiply([precompute_L[1][i], precompute_L[2][i], precompute_L[3][i]], LL3x3);
		let L_SH_R_5 = math.multiply([precompute_L[4][i], precompute_L[5][i], precompute_L[6][i], precompute_L[7][i], precompute_L[8][i]], LL5x5);

		result[0][i] = precompute_L[0][i];
		result[1][i] = L_SH_R_3._data[0];
		result[2][i] = L_SH_R_3._data[1];
		result[3][i] = L_SH_R_3._data[2];
		result[4][i] = L_SH_R_5._data[0];
		result[5][i] = L_SH_R_5._data[1];
		result[6][i] = L_SH_R_5._data[2];
		result[7][i] = L_SH_R_5._data[3];
		result[8][i] = L_SH_R_5._data[4];
	}
	return result;
}
```

下面以求第一阶的系数变换为例：
```JS
function computeSquareMatrix_3by3(rotationMatrix) { // 计算方阵SA(-1) 3*3 

	// 1、pick ni - {ni}
	let n1 = [1, 0, 0, 0]; let n2 = [0, 0, 1, 0]; let n3 = [0, 1, 0, 0];

	// 2、{P(ni)} - A  A_inverse
	let Pnn1 = SHEval3(n1[0], n1[1], n1[2], 3);
	let Pnn2 = SHEval3(n2[0], n2[1], n2[2], 3);
	let Pnn3 = SHEval3(n3[0], n3[1], n3[2], 3);

	//let PnMT = math.matrix([Pn1, Pn2, Pn3]);
	let PnMT = math.matrix([
		[Pnn1[1], Pnn2[1], Pnn3[1]],
		[Pnn1[2], Pnn2[2], Pnn3[2]],
		[Pnn1[3], Pnn2[3], Pnn3[3]],
	]);

	let PnMI = math.inv(PnMT);

	// 3、用 R 旋转 ni - {R(ni)}
	//let rotateMat = mat4Matrix2mathMatrix(rotationMatrix);
	let nr1 = math.multiply(rotationMatrix, n1);
	let nr2 = math.multiply(rotationMatrix, n2);
	let nr3 = math.multiply(rotationMatrix, n3);

	// 4、R(ni) SH投影 - S

	Pnn1 = SHEval3(nr1[0], nr1[1], nr1[2], 3);
	Pnn2 = SHEval3(nr2[0], nr2[1], nr2[2], 3);
	Pnn3 = SHEval3(nr3[0], nr3[1], nr3[2], 3);

	PnMT = math.matrix([
		[Pnn1[1], Pnn2[1], Pnn3[1]],
		[Pnn1[2], Pnn2[2], Pnn3[2]],
		[Pnn1[3], Pnn2[3], Pnn3[3]],
	]);

	// 5、S*A_inverse
	let ret = math.multiply(PnMT, PnMI);
	return ret;
}
```

通过这样的方式，我们就可以得到环境光在旋转后的Lighting值。效果如下：
![](https://gitee.com/nhkao/pic-go/raw/master/20250302213653030.png)![](https://gitee.com/nhkao/pic-go/raw/master/20250302213737510.png)