---
title: 调试总结
date: 2025-03-04 16:08:37
categories:
    - 工具集 
tags:
    - 调试技能总结
---

<div align='center' ><font size=7>调试经验总结</font></div>

这里我使用的是VS2022进行调试！

## 1.断点调试
最简单的就是在需要调试的行前面打上断点，这样，当程序运行到此处时，便会停留在断点所在行。但这里可能会遇到断点打不上的问题。断点打不上的根本原因就是程序正在调用的pdb与其链接的lib不一致导致的。以下是可能的解决方案。

1. 重新编译项目文件
2. 若出现部分断点能够打上，可能是优化问题，尝试关闭优化后在编译
3. 确保允许的dll与链接的lib是同一个。重新生成后，检查项目运行所用的dll与lib生成的日期是否相同
4. 调整所引用的lib的所在的顺序，将其放到最前面。这是因为lib中符号会出现覆盖问题，即使有些变量声明在cpp中，依然会出现覆盖问题，详见文章
5. vs缓存问题，这个可能是vs的问题，请尝试清除vs的缓存或者直接重启vs，这个问题我遇到过很多次。
6. lib缓存问题，会出现新增的函数始终无法打上断点，可以尝试先移除lib（这时会报很多链接错误），在重新加入lib。
7. 待补充...



## 2.查看变量值

当完成了可以打上断点后，可以将鼠标悬浮在变量上面，这时会出现一些变量信息，如图：
![](https://gitee.com/nhkao/pic-go/raw/master/20250304164805863.png)

可以看到，该变量的指针值，因为该变量是一个share_ptr，可以看到它的引用计数为1，弱引用计数为1

## 3.值更改时中断

如果将鼠标放到对应的成员上，右键，可以设置值更改时中断！

![](https://gitee.com/nhkao/pic-go/raw/master/20250304165120456.png)
这是一个很强力的功能，比如对于图片中的例子，这应该是一个容器。在_Mysize处设置值更改时中断后，在代码运行过程中，任何该容器添加或移除变量的操作都会被立刻中断。这样就可以很清晰的知道这个变量是在什么时候被修改的了。

## 4.拖动调试

若按F9单步调试时，按过了你需要查看的变量值，这是你可以鼠标悬浮在左侧箭头处，拖动到你需要执行的代码处，这样就可以反复的执行一段函数。此外该拖动也支持向下拖动，也就是说，可以直接跳过一些你觉得目前不需要执行的代码块。

## 5.对于顶部的功能按钮：

![](https://gitee.com/nhkao/pic-go/raw/master/20250304165758718.png)

这个热重载的功能是用于运行时的，也就是说，在调试的过程中，可以修改部分代码，直接热重载而不需要重新编译运行！这大量减少了调试所需的时间，特别是当你调试了很长时间才调试到你关注的代码块时，发现只是需要简单的改变某个代码块的一小部分内容。它可以帮助你直接修改代码并运行，省去了关闭程序，重新编译，在运行到此处的时间！

该功能要启用，首先需要关闭优化，此外，还需要将C++->常规->调试信息格式 修改为编辑并继续。此外，该修改只适用于小规模的修改，似乎不能超过函数块原本分配的栈大小。

## 6.多线程调试
在多线程调试中，经常会遇到调试代码在不同线程中调整的苦恼，特别是有好几个相同的线程时，同一个变量在不同线程中取值不同，调试会很困扰。
![](https://gitee.com/nhkao/pic-go/raw/master/20250304171545082.png)
如图，打开线程面板，可以看到当前cup执行的是某个线程。这时，可以点击暂停键，冻结线程，这样，cpu就只会执行未冻结的线程，代码也不会在不同的线程中跳转了。

## 7.DLL调试
一般来讲，只要目标程序使用了我开发的dll，都可以调试他的代码。这里可以区分三种方式。

### 1.对方是用我的安装包运行的
这时，可以使用vs的远程调试工具msvsmon.exe,设置相应权限后，在本机中，使用vs的调试->附加到进程->远程，输入相应的ip地址，就可以实现局域网内的远程调试，至于跨外网调试，暂时还不清楚该怎么做。

### 2.对方软件使用到了我的dll
这是，我们可以以dll的方式启动对方的整个软件。

![](https://gitee.com/nhkao/pic-go/raw/master/20250304174755482.png)

在调试界面，使用远程调试，配置相应的ip地址，与1中相似，这样，我就可以以dll的方式启动对方的程序，在我的dll库中打上断点，让对方的程序调用到我的库时，就可以实现断点中断了！

### 3.对方在软件使用过程中调用我的dll

这里与2不同的时，对方并不会在程序启动的时候调用我的dll，而是以延迟的方式加载我的dll。比较常见的是，前端调用C++库进行一些耗时的计算。这时，就会以加载动态库的方式调用C++ dll。
对此，我们举一个简单的例子：

首先看c动态库的方式

创建CreateC.dll
```c
//cfun.h
#ifndef CFUN
#define CFUN

extern "C" __declspec (dllexport) int funAdd(int a, int b);

#endif // !CFUN
```

```c
//cfun.cpp
#include <stdio.h>
#include "cfun.h"

int funAdd(int a, int b)
{
	int c = a + b;
	printf("a + b = %d \n", c);
	return c;
}
```
以动态库的方式生成，就可以生成CreateC.dll

调用端代码一般如图：
```c++
#include <iostream>
#include <Windows.h>

int main()
{
	std::cout << "start load dll ..." << std::endl;

	using fun = int(*)(int, int);

	const char* dllName = "CreateC.dll";
	//const char* dllName = R""(C:\Users\22676\Desktop\mytest\C++_TEST\Test2LoadDll\createCDll\bin.x64\createCDll.dll)"";
	// 加载动态库
	HMODULE hDLL = LoadLibrary(dllName);
	if (!hDLL) {
		std::cerr << "Failed to load library: " << hDLL << std::endl;
		return 0;
	}

	// 获取函数指针
	fun f = (fun)GetProcAddress(hDLL, "funAdd");

	if (!f)
	{
		auto s = GetLastError();
		std::cerr << "Failed to load library: " << f << std::endl;
		return 0;
	}

	int c = f(2, 3);

	std::cout << "c = " << c << std::endl;

	FreeLibrary(hDLL);
	system("pause");
	return 0;
}
```
以这种方式，就可以以动态加载的方式，调用所需要的dll。所以，对于如何调试这种代码也有了思路。其方法就是在生成端起始处生成一个弹窗，这样，当调用端使用到CreateC.dll时，程序就会暂停，这时，就可以以方式2进行调试。

### 4. 补充部分

前面描述的时传统c风格的接口，但是对于C++，我们该如何调用呢？
其实，最常用的方法就是多套一层，在c接口中调用C++的代码就可以了。

比如如下的代码
```c++
//interface.h
#pragma once
extern "C"
{
	__declspec(dllexport) int startScore(const char* dataJson);

	__declspec(dllexport) int saveSnapshotEx(const char* dataJson, const char* pluginsPath);

}
```
```C++
int startScore(const char* dataJson)
{
	ScoreWork::getInstance()->setDataJson(dataJson);
	return ScoreWork::getInstance()->getResult();
}

int saveSnapshotEx(const char* dataJson, const char* pluginsPath)
{
	return ScoreWork::getInstance()->saveSnapshotEx(dataJson, pluginsPath);
}
```


对于调用者而言，方式和c风格是完全一致的。

此外，这里还有一点需要留意的传参。这里都是以字符串的形式进行传参。那C++该如何更好的利用这点做接口的隔离呢？这就是**反射**的内容了。