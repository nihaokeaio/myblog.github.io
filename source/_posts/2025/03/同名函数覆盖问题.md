---
title: 同名函数覆盖问题
date: 2025-03-05 20:01:21
categories:
    - Cpp
    - 基础知识
tags:
    - Cpp
---
## C++命名空间以及污染问题
这是我在调用函数的遇到的一个问题。是一个使用CPP的坑。这里我使用抽象出来的代码块来演示。

一共有多个文件如下：
```C++
//A.h
#pragma once
class A
{
public:
	int getASum();
};
```

```c++
//A.cpp
#include "A.h"
struct commonData
{
	int a = 1;
	int b = 2;
};
int A::getASum()
{
	commonData A;
	return A.a + A.b;
}
```

```c++
//B.h
#pragma once
class B
{
public:
	int getBSum();
};
```
```c++
#include "B.h"

struct commonData
    {
        commonData()
    {
        d = new int(6);
    }
    ~commonData()
    {
        delete d;
    }

    int a = 3;
    int b = 4;
    int c = 5;
    int* d;

    int getcommonData()
    {
        return a + b + *d;
    }
};

int B::getBSum()
{
	commonData A;
    //return A.getcommonData(); //return 3
	return A.a + A.b;
}
```

调用处代码
```c++
#include "B.h"
#include "A.h"
#include <iostream>
void main()
{
	A a;
	B b;

	std::cout << a.getASum() << std::endl;  // return 3
	std::cout << b.getBSum() << std::endl;  // return 3

	getchar();
}
```

这里有一个很大的问题，就是A.cpp中的``commonData``数据结构覆盖率B.cpp中的数据。无论B.cpp中的``commonData``如何声明，都会无效，调用B的``getcommonData``方法还会出现崩溃，d未初始化的问题。

同样，这个问题即使是在跨项目调用的时候也会出现问题。比如原有项目P0，我在另一个项目P1中写了C类，同时在C.cpp中创建了结构体``commonData``，这时我引用P0生成的**静态库**，使用类似的调用方法，这时，C.cpp中的``commonData``就会覆盖A.cpp中的结构体，导致可能会出现的崩溃。比如这个例子中，假设C.cpp的代码和B.cpp几乎相同，那么由于覆盖问题，A.cpp也会被当成B.cpp,而B中有指针的操作，可能就会出现问题。

以下是deepseek的解释：
```
对于未初始化的全局变量（如 int myVar;），某些编译器（如GCC）会将其标记为Common Symbol。
链接器会合并所有同名Common Symbol，最终使用其中一个定义（通常是最后链接的）
结果编译失败，无法生成可执行文件

类的定义在C++中默认具有外部链接，但链接器不检查类定义的一致性
程序可能通过编译，但会导致未定义行为（如内存布局不一致、函数调用错误）

如果发现多个同名的强符号（如已初始化的全局变量），报错。
如果发现同名的弱符号（如Common Symbol），选择其中一个。
```

另外，我验证了动态库似乎不会出现问题。这可能是由于动态库的lib只包含函数签名信息，不包含实现。因此在链接时不会出现覆盖的问题。

解决方案其实很简单，加一个命名空间就可以了！