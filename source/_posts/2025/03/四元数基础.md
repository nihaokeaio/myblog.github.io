---
title: 四元数基础
date: 2025-03-10 10:01:06
categories:
    - 算法
    - 动画
tags:
    - 四元数
---

## 四元数基础

四元数的基础资料网上很多，比如:[四元数(Quaternions)](https://www.zhihu.com/tardis/zm/art/97186723?source_id=1005)，这里就不做过多赘述。本文主要给出代码层面的使用。

```c++
 struct Quaternion
 {
     double w;  // 实部
     double x;  // i 的系数
     double y;  // j 的系数
     double z;  // k 的系数
     // 构造函数
     Quaternion(double w = 0, double x = 0, double y = 0, double z = 0) : w(w), x(x), y(y), z(z) {}

     Quaternion(const Vec3f& v) : w(0), x(v.X()), y(v.Y()), z(v.Z()) {}

     Quaternion(double val, const Vec3f& v) : w(val), x(v.X()), y(v.Y()), z(v.Z()) {}
 }
```

首先给出四元数的定义，以及相应的构造函数。

```c++
// 四元数乘法
///q1=[s,V]
///q2=[t,U]
/// q1*q2=[s*t-V*U,s*U+t*V+VxU]
Quaternion operator*(const Quaternion& other) const
{
    return Quaternion(
        w * other.w - x * other.x - y * other.y - z * other.z,
        w * other.x + x * other.w + y * other.z - z * other.y,
        w * other.y - x * other.z + y * other.w + z * other.x,
        w * other.z + x * other.y - y * other.x + z * other.w
    );
}
// 四元数共轭
Quaternion conjugate() const
{
    return Quaternion(w, -x, -y, -z);
};

// 四元数加法
Quaternion operator+(const Quaternion& other) const {
    return Quaternion(w + other.w, x + other.x, y + other.y, z + other.z);
}

// 四元数数乘
Quaternion operator*(double scalar) const {
    return Quaternion(w * scalar, x * scalar, y * scalar, z * scalar);
}

// 四元数点积
double dot(const Quaternion& other) const {
    return w * other.w + x * other.x + y * other.y + z * other.z;
}

// 计算四元数的模长
double magnitude() const {
    return std::sqrt(w * w + x * x + y * y + z * z);
}

// 四元数归一化
Quaternion normalize() const {
    double mag = magnitude();
    if (mag > 0) {
        return Quaternion(w / mag, x / mag, y / mag, z / mag);
    }
    return Quaternion(1, 0, 0, 0); // 处理模长为 0 的情况
}
```

这里讲述了四元数的基本运算规则，包含了加，乘，点乘，数乘，共轭，归一化。

```c++
Vec3f toVec()
{
    return Vec3f{ (float)x, (float)y, (float)z };
}

static void quatToMat(const Quaternion& q, core::Matrix44f& m)
{
    m.SetIdentity();
    float x2 = q.x * 2.;
    float y2 = q.y * 2.;
    float z2 = q.z * 2.;
    {
        float xx2 = q.x * x2;
        float yy2 = q.y * y2;
        float zz2 = q.z * z2;
        m[0][0] = 1.0f - yy2 - zz2;
        m[1][1] = 1.0f - xx2 - zz2;
        m[2][2] = 1.0f - xx2 - yy2;
    }
    {
        float yz2 = q.y * z2;
        float wx2 = q.w * x2;
        m[1][2] = yz2 - wx2;
        m[2][1] = yz2 + wx2;
    }
    {
        float xy2 = q.x * y2;
        float wz2 = q.w * z2;
        m[0][1] = xy2 - wz2;
        m[1][0] = xy2 + wz2;
    }
    {
        float xz2 = q.x * z2;
        float wy2 = q.w * y2;
        m[2][0] = xz2 - wy2;
        m[0][2] = xz2 + wy2;
    }
}
       
static void matToQuat(const core::Matrix44f& m, Quaternion& q)
{
    if (m[0][0] + m[1][1] + m[2][2] > 0.0f) {
        float t = m[0][0] + m[1][1] + m[2][2] + 1.0f;
        float s = (float)0.5 / math::Sqrt(t);
        q.w = s * t;
        q.z = (m[1][0] - m[0][1]) * s;
        q.y = (m[0][2] - m[2][0]) * s;
        q.x = (m[2][1] - m[1][2]) * s;
    }
    else if (m[0][0] > m[1][1] && m[0][0] > m[2][2]) {
        float t = m[0][0] - m[1][1] - m[2][2] + 1.0f;
        float s = (float)0.5 / math::Sqrt(t);
        q.x = s * t;
        q.y = (m[1][0] + m[0][1]) * s;
        q.z = (m[0][2] + m[2][0]) * s;
        q.w = (m[2][1] - m[1][2]) * s;
    }
    else if (m[1][1] > m[2][2]) {
        float t = -m[0][0] + m[1][1] - m[2][2] + 1.0f;
        float s = (float)0.5 / math::Sqrt(t);
        q.y = s * t;
        q.x = (m[1][0] + m[0][1]) * s;
        q.w = (m[0][2] - m[2][0]) * s;
        q.z = (m[2][1] + m[1][2]) * s;
    }
    else {
        float t = -m[0][0] - m[1][1] + m[2][2] + 1.0f;
        float s = (float)0.5 / math::Sqrt(t);
        q.z = s * t;
        q.w = (m[1][0] - m[0][1]) * s;
        q.x = (m[0][2] + m[2][0]) * s;
        q.y = (m[2][1] + m[1][2]) * s;
    }
}
```

这里给出四元数和三维向量，齐次矩阵之间的转换。

```c++
//t=>[0,1]
static Quaternion interpolate(const Quaternion& q1, const Quaternion& q2, float t)
{
    Quaternion q0 = q1;
    float d = q0.dot(q2);
    if (d < 0)
    {
        d = -d;
        q0 = q0 * -1.;
    }

    const double DOT_THRESHOLD = 0.9995;
    if (d > DOT_THRESHOLD) {
        // 接近 0 夹角时使用线性插值
        return q0 * (1 - t) + q2 * t;
    }

    double theta = std::acos(d);
    double sinTheta = std::sin(theta);

    double s0 = std::sin((1 - t) * theta) / sinTheta;
    double s1 = std::sin(t * theta) / sinTheta;

    return q0 * s0 + q2 * s1;
}
```

然后，给出四元数的插值，角度较小时，可以使用普通线性插值，否则，可以使用球面线性插值。

```c++
void TestQuaternion::rotate(core::Vec3f& ret, const core::Vec3f& ori, const core::Vec3f& rotateAxis, const float angle)
{
    GMath::Quaternion qO(ori);
    float halfAngle = angle / 2;
    GMath::Quaternion qR(cos(halfAngle), rotateAxis * sin(halfAngle));
    GMath::Quaternion qRet = qR * qO * qR.conjugate();
    ret = qRet.toVec();
}
```

最后，给出一个使用四元数进行旋转的案例。