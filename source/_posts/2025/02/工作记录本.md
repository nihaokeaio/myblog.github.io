---
layout: _page
title: 工作记录本
tags work:
---

解决bug处理方案

1 在SVN反复对比，保留关键代码，去除无关代码，提交时附上禅道对应的BUG编号以及相应说明

2 在钉钉CAD群@xxx，格式如下：
    @杨振江(杨振江)
    commit
    ModelSculpt\
    20211 添加完附件应用后，快捷键撤销失败

3 在禅道上处理相应BUG的后续：

解决方案：已解决
解决版本：下个版本
备注：
    原因：切换牙齿的时候没有清除上一个牙齿的实时倒凹区

    解决办法：增加了切换牙齿后隐藏了上一牙齿的实时倒凹区

```C++
MeshIO::writeMesh(*sourceCutMesh.get(), QString("C:\\Users\\22676\\Desktop\\temp\\sourceCutMesh_%1.um").arg(pTooth->getId()));
MeshIO::writeMesh(*pExtractMesh.get(), QString("C:\\Users\\22676\\Desktop\\temp\\pExtractMesh_%1.um").arg(pTooth->getId()));
```

### 关于三点配准与拖拽器 ###
首先，人眼看到的模型位置可解分为世界坐标**Tw**和模型坐标**Tm**的乘积。这里拖拽器改变的是世界坐标，而函数fun
```c++
static void transformation(Mesh *pMesh, const Matrixf& mx, bool isPost = true);
```
改变的是模型坐标，是两套不同的坐标系统，为了与实际表现的效果相同。需要做一定的矩阵运算

定义一些参数
D：拖拽器的矩阵，可以具体为：```D3=P3*P2*P1```,表明拖拽器依次执行了P1,P2,P3三步操作，每一步都是一个变换矩阵，为左乘。拖拽器拖拽后，模型的在空间的位置为```D3*Tm```。

**函数fun**

由于不能直接设置拖拽器的矩阵，因此需要重置模型位置时只能通过改变模型矩阵Tm实现位置变换。
重置时，我们 调用函数```transformation(Mesh *pMesh, const Matrixf& mx, bool isPost = true);```,其中，mx是变换矩阵。对于拖拽器产生的空间变换，使得$mx=D3^{-1}$就可以重置模型位置。此时，世界矩阵仍然为Tw=D3，而模型矩阵为$Tm=D3^{-1}*Tm$，两者乘积表现为模型恢复到了最开始的位置。

基于以上的基本条件，下面逐个介绍其他情况

### 拖拽-重置-拖拽

前两步，前面可以得到Tw=D3，$Tm=D3^{-1}Tm$,再次拖拽后，Tw=P4*D3=D4;这时，mx应该为$D3^{-1}*P4^{-1}*D3$;此时，
$$
Tw*mx*Tm=P4*D3*(D3^{-1}*P4^{-1}*D3)*(D3^{-1}*Tm)=Tm
$$

因此，需要记录上一步重置前的矩阵D3。定义为M矩阵。
所以$mx=D^{-1}*M$;

### 当加入三点配准后

同样，三点配准直接改变模型矩阵。假定变换矩阵为Q。

#### 若直接配准
$$
Tw=I;\\
mx=Q\\
TM=Tm;
$$
重置时，$mx=Q^{-1}*D^{-1}*M$即可
#### 拖拽后配准
这里引入重置矩阵AlT;重置时，执行$Tw*AlT^{-1}*M*TM$
$$
Tw=D;\\
mx=D^{-1}*Q*D;\\
TM=Tm;\\
ALT=M^{-1}*D^{-1}*Q*D^2
$$

#### 拖拽重置后配准

$$
Tw=D;\\
mx=D^{-1}*Q*D;\\
TM=D^{-1}Tm;\\
ALT=M^{-1}*D^{-1}*Q*D^2
$$
....***太麻烦了，以后再写吧***

最后
得到ALT为
$$
ALT=M*D^{-1}*Q*D*M^{-1}*ALT
$$



## 定时器的简单使用
```C++
#inlucde <chrono>
auto start = chrono::system_clock::now();
// do something...
auto end = chrono::system_clock::now();
//计算得到时间片数
auto duration = chrono::duration_cast<chrono::microseconds>(end - start);
//将其转换成秒
//其中，chrono::microseconds::period::den = 1000_000,num=1
auto useTime = double(duration.count()) * chrono::microseconds::period::num / chrono::microseconds::period::den;
const QString str = QString("C:\\Users\\22676\\Desktop\\testModel\\") + QString("ToothSplit.txt");
//将其保存到文件中,Append添加模式
QFile f(str);
if (!f.open(QIODevice::Append | QIODevice::Text))
{
    qDebug() << ("打开文件失败");
}
QTextStream txtOutput(&f);
txtOutput << QString::number(tooth_->getId()) << " :  ";
txtOutput << QString::number(useTime) << " \n";
f.close();
```

//由于以render为父类的面板无法发送事件（按键）给主场景，因而需要在面板事件中主动激活场景
/*
包含了一下面板
TutorialPanel
StateNavigation::Instance()
VisiualNavagationBar::instance()
IToothDiagram::Instance()
IModelTree::Instance()
IApply
以及以下父类面板
UPAttBase
UPAttEditBase
*/

## lib,exe,dll文件查看，可以是用自带的dumpbin.exe工具
```
https://www.lulutong.net.cn/?p=178
```
或者使用工具Dependencies.exe，使用
```cmd
.\Dependencies.exe -chain -json file.dll(.exe) > outfile.txt
#当数据太大是，可以使用 -depth 3参数（递归深度）
```


## 在QT中，UI部分往往需要在主线程中执行，这里展示两种方法，将部分子线程移动到主线程

1.使用```QMetaObject::invokeMethod```方法
```C++
QMetaObject::invokeMethod(&IModelTree::Instance(), [this,meshtag]()
{
        IModelTree::Instance().slotSetToothUnitItem(this, meshtag);
},Qt::AutoConnection);
```
这是一个QT的静态方法，可以将object的相关函数转移到主线程中去执行

```cpp 
class FunctionThreadTransfer :public QObject
{
	Q_OBJECT
public:
	explicit FunctionThreadTransfer(QObject* parent = nullptr);


	void execInMainThread(const std::function<void(design::MeshType, std::shared_ptr<core::Drawable>, bool, bool)>& f,
		design::MeshType type, SmartDrawable draw, bool bCreateNode, bool isSendSignalSetMesh);

signals:
	void signalToMainThread(const std::function<void(design::MeshType, std::shared_ptr<core::Drawable>, bool, bool)>& f,
		design::MeshType type, SmartDrawable draw, bool bCreateNode, bool isSendSignalSetMesh);

public slots:
	void exec(const std::function<void(design::MeshType, std::shared_ptr<core::Drawable>, bool, bool)>& f,
		design::MeshType type, SmartDrawable draw, bool bCreateNode, bool isSendSignalSetMesh);
};
```
这里定义了一个转移线程的类，其cpp文件如下
```cpp {.line-numbers}
FunctionThreadTransfer::FunctionThreadTransfer(QObject* parent)
{
	//将子线程移到主线程，并以阻塞方式执行
	connect(this, &FunctionThreadTransfer::signalToMainThread, this, &FunctionThreadTransfer::exec, Qt::BlockingQueuedConnection);
}

void FunctionThreadTransfer::execInMainThread(const std::function<void(design::MeshType, std::shared_ptr<core::Drawable>, bool, bool)>& f,
	design::MeshType type,SmartDrawable draw, bool bCreateNode, bool isSendSignalSetMesh
	)
{
	exec(f, type, draw, bCreateNode, isSendSignalSetMesh);
}

void FunctionThreadTransfer::exec(const std::function<void(design::MeshType, std::shared_ptr<core::Drawable>, bool, bool)>& f,
	design::MeshType type, SmartDrawable draw, bool bCreateNode, bool isSendSignalSetMesh)
{
	///判断当前线程是否为主线程
	if(QThread::currentThread() == QApplication::instance()->thread())
	{
		f(type, draw, bCreateNode, isSendSignalSetMesh);
	}
	else
	{
		emit signalToMainThread(f, type, draw, bCreateNode, isSendSignalSetMesh);
	}
}
```
其中，比较关键的就是connect函数，该槽函数连接可以以阻塞的方式，将信号发送的函数转移到主线程中执行,此外通过```QThread::currentThread() == QApplication::instance()->thread()```判断当前线程是否为主线程。该代码要是能优化成模板版本就好了.


## 冠内层，外层，最小厚度层
### 内层
对间隙进行加工所形成的层
### 外层
冠外部的层，与内层形成封闭的图形
### 最小厚度层
外层的最小范围，若小于内层，则封闭模型可能太薄


### build insights 失败
使用build insights时需保证 NT Kernel Logger 停止运行
在管理员cmd中使用命令 ```logman query -ets```查看使用情况，并使用```xperf -stop "NT Kernel Logger"```来停止事件


### 预编译头创建过程

1. 使用build insights 分析头文件引用的关系
2. 在项目中创建pch.h,pch.cpp文件
3. 在pch.h文件中添加引用耗时（次数）较高的头文件
4. 设置pch.cpp文件的文件属性：C++->预编译头->创建，并配置好所使用的头文件以及输出的预编译头文件所在位置
5. 在工程项目属性中，C++->预编译头->使用，并添加对应的预编译头文件位置以及头文件名称。
	1. 手动添加头文件方式
		1. 将所有的项目中的cpp文件最开始包含上pch.h文件，否则编译会无法通过
		2. 若有QT的moc文件，则需要手动在自定义生成事件中添加命令``-b "pch.h"``
		3. 无法使用QT的``Qt Meta-Object Compiler (moc)``生成

	2. 或者在项目配置->C++->高级->强制包含pch.h文件，这样就可以直接使用预编译头了 



### 使用命令行构建项目
使用vs自带的``devenv``工具，最好将其放入环境变量中。

其中``devenv.exe``不会输出编译结果，类似于后台静默编译，若需要看到编译结果，可以
使用 ``/Out out.log``指令，会将输入结果输出到文件中。若需要实时看到编译结果，则可以使用``devenv.com``工具。

这里注意：使用``devenv.com``的同时输出到文件，会以当前系统（(VS)的默认编码方式输出，而``devenv.exe``会以utf-8的方式输出。

这里给出一个范例:

```bash
#build->Release|win64
devenv.exe .\UpDataAnalyze.sln  /build "Release" /Project "UpDataAnalyze.vcxproj" /ProjectConfig "Release|x64"  /Out log.txt
#rebuild->Debug|win32
devenv.exe .\UpDataAnalyze.sln  /Rebuild "Debug" /Project "UpDataAnalyze.vcxproj" /ProjectConfig "Debug|win32"  /Out log.txt
#rebuild->整个项目
devenv.com .\UpDataAnalyze.sln  /Rebuild "Release|x64"
```


### 对于lambda表达式的信号槽连接

没有现成的重载函数重载带连接类型的lambda表达式，因此，可以以一下方式绑定
```c++S
const auto& onlinePostFun = [this](bool permissionSuccess) {
	if (!permissionSuccess)
	{
		emit page_->signalDonglePermission(permissionSuccess);
	}		
};
QObject object;
connect(page_, &QDesignPage::signalDonglePermission, qApp, onlinePostFun, Qt::QueuedConnection);
connect(page_, &QDesignPage::signalDonglePermission, &object, onlinePostFun, Qt::QueuedConnection);
```

### 四元数的旋转
四元数相关的定义以及一些应用不在介绍，需要明确关键的等式。
对于一个三维向量v(x,y,z),其绕轴u(ux,uy,uz)旋转θ角度，对于四元数的表示。

首先，先用四元数表示旋转向量与角度。q=[cos(θ/2)，u*sin(θ/2)];

其次三维向量v可以用四元数表示为：p=[w,x,y,z]；

根据四元数的一些性质我们可以得到旋转后的四元数$t=q*p*q^{-1}$,对于单位四元数，也有$q^{-1}=q^{*}$

此外，对于四元数的插值，一般用于矩阵变换插值。即若有变换矩阵TM,对其变换进行插值。

1. 首先对TM进行转换，对于旋转部分，将其变换成四元数q，通过四元数的性质，我们可以认为：
	对于矩阵插值，等同于对于四元数的插值。四元数有两种基本的插值方式。均匀插值和球面插值。
	代码为：
	```C++
	static Quaternion interpolate(const Quaternion& q1, const Quaternion& q2, float t)
	{
		Quaternion q0 = q1;
		float d = q0.dot(q2);
		if (d < 0)
		{
			d = -d;
			q0 = q0 * -1.;
		}

		const double DOT_THRESHOLD = 0.9995;
		if (d > DOT_THRESHOLD) {
			// 接近 0 夹角时使用线性插值
			return q0 * (1 - t) + q2 * t;
		}

		double theta = std::acos(d);
		double sinTheta = std::sin(theta);

		double s0 = std::sin((1 - t) * theta) / sinTheta;
		double s1 = std::sin(t * theta) / sinTheta;

		return q0 * s0 + q2 * s1;
	}
	```
2. 对于平移部分，这里使用对平移向量的采用均匀插值即可。

3. 对于某一时刻的t，可以计算得到平移矩阵TT,旋转矩阵TR，原始矩阵TO,可以得到t时刻的
	矩阵$TT*TR*TO$;代码如下：
	```C++
	float fac = ShapingFun::doubleExponentialSigmoid(factor, 0.426);
	//do
	Quaternionf qt = core::Interpolate(qO_, qR_, fac);
	Matrix44f mat;
	qt.ToMatrix(mat);

	Vec3f mV = moveVec_ * fac;

	Matrix mT;
	mT.SetTranslate(mV);
	rootNode_->setMatrix(mT * mat * nodeOriMat_);
	```
4. 对于过度动画，难点就是在动画执行过程中再次插值，导致出现奇怪的问题。例如:
	```c++
	void ShortcutToolSpace::QuatTrans::setTransMat(const std::shared_ptr<core::MatrixTransform>& rootNode, 
	const core::Matrix44f& transMat,float duration)
	{

		impl_->rootNode_ = rootNode;
		impl_->duration_ = duration;

		Matrix44f tM = transMat * impl_->nodeReTMat_ * Inverse(impl_->nodeOriMat_);
		impl_->nodeReTMat_ = transMat * impl_->nodeReTMat_;
		impl_->nodeOriMat_ = impl_->rootNode_->getWorldMatrix();

		impl_->qR_.FromMatrix(tM);
		impl_->moveVec_= tM.GetColumn3(3);

		impl_->timer_.start();
	}
	```
	这段代码看起来是可以的，但是若有别处直接修改了``impl_->rootNode_->getWorldMatrix()``，就会
	导致结果出错。
	